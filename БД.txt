Модуль 3.
Разработка серверной части, категория.
База данных - это набор информации, которая хранится упорядоченно в информационном виде.
Реляционные бд - это данные, представлены в виде таблиц. (Excel). Часто в терминалогии таблицы называются - сущностями.
Значение первых строк в каждой таблице - это критерии сущности. (атрибуты).
Основные SQL бд выражены в виде наиболее популярных приложений (сервер бд):
1. PostgreSQL.
2. MySQL.
3. SQLserver.
УСТАНОВИТЬ ДОМА
Для работы с сервером Postg SQL, зачастую используется отдельное клиентское приложения, для упрощения работы.
Каждое значение первой строки, каждой таблицы является атрибутом. Значение атрибутов читаются построчно, начиная со второй строки.
Первая колонка должна являться первичным ключом. Первичный ключ - это уникальное значение, которое присвоено каждой первой строке. Должен быть целым числом, не отрицательное, не ноль и должен являться автоинкриментом (i++).
Определение нормальных форм. Внешний ключ - это ссылка из смежной таблицы на первичный ключ в таблице, с которой она связана.
Для того, чтобы будущая бд коректно работала ее необходимо нормализовать или привести к третьей нормальной форме.
Первая нормальная форма (н.ф.) - это все атрибуты и их значения автомарны (Неделимы). 
Вторая нормальная форма (2н.ф.) - это колонка с айдишниками. (ID)
Третья нормальная форма (3 н.ф.) - создается смежная таблица, атрибуты которой является внешними ключами.

SQL запрос - это команда, через которую работает БД: выгружают из них данные, заменяют, сортируют, удаляют.
SQL запросы делят на следующие основные типы: 
1. DDL запрос - это операторы определения данных, которые работают с целыми таблицами.
Create - создать.
Drop - удалить.
Use - использовать.

2. DML запрос - содержит в себе операторы манипуляции данными, которые работают с содержимым таблицы.
Update - обновить.
Select - выбрать.
Delete - удалить.
Insert - добавить.

3. DCL запрос - это операторы определения доступа к данным для разных пользователей.
Grant - предоставить.
Revoke - отозвать.
Deny - запретить.

4. TCL запрос - это язык управления транзакцией, т.е. сериями команд, которые выполняются по очередно. Если хотя бы одна из команд не выполнена, все последующие отменяются.
Пример: Онлайн оплата.
Begin transaction - начало транзакции.
Commit transaction - изменение команд в цепочке.
Save transaction - сохрание транзакции.

Типы данных.
Наиболее подходящий тип данных для первичных ключей - это serial (smallserial, bigserial).
Если количество символов примерно известно заранее и оно составляет не более 255, то лучше использовать varchar. Если нужно ограничение до 10 символов, то пишется varchar(10).
Если нужно неограниченное количество символов, то пишем динамическую величину (тип данных) - text.
Для значений с плавающей точкой, изспользуется numeric. (Пример: рейтинг).
Для целочисленных значений, без автоинкримента, используется типы данных - integer (smallint, bigint).
Внешний ключ должен описываться типом данных - integer. 
timestamp - используется для фиксации дат.

Ограничение для чека/статуса. (Открыть/Закрыть):
alter table orders  
add check (status in ('открыт', 'закрыт'))

1. Запрос на выведения всех данных из таблицы "клиенты":
select * from clients   

2. Запрос с условием. (вывести все закрытые заказы):
select * from orders where status = 'закрыт'

3. Запрос. Вывести все товары дороже 200 рублей:
select * from products where price > 200

4. Запрос. Условие с фильтрацией. Вывести имена и рейтинг клиентов выше 3.5 и отсортировать по возрастанию:
select name, rating from clients where rating > 3.5 
order by rating desc
___________________________
select name, rating from clients where rating > 3.5 
order by rating asc

desc - сортирует по убыванию.
asc - сортрует по возрастанию.

5. Запрос. (Вывести информацию о клиенте, фамилия которого начинается на Г:
select * from clients where name like 'Г%' 
'Г%' - фамилия начинается на Г.
'%Г%' - буква Г в любом месте.
'%Г' - фамилия заканчивается на букву Г.

6. Запрос. Вывести общее количество клиентов:
select count (*) as total_clients
from clients 

7. Запрос. ти среднее значение цен на все товары:
select avg (price) as  avg_price from products 

8. Запрос. Вывести цены самого дорогого и самого дешевого товар:
select max (price) as max_price, min (price) as in_price from products 

9. Запрос. Вывести количество заказов по статусу:
select status, count(*) as orders_count from orders 
group by status 

10. Запрос. Вывести все заказы с инфо о клиентах и товарах (вывести id заказа, фио, цена, статус, дата и д.р):
select 
o.order_id,
c.name as client_name,
p.name as product_name,
p.price,
o.status,
o.date
from orders o 
join clients c on o.client_id = c.client_id 
join products p on o.product_id = p.product_id 

orders o - временная переменная.

11. Запрос. Вывести средний чек о клиентах:
select 
c.name as client_name,
avg (p.price) as avg_order
from orders o 
join clients c on o.client_id = c.client_id 
join products p on o.product_id = p.product_id 
group by c.name 
order by avg_order asc 

11. Запрос. Вывести id и ФИО клиентов, которые не делали заказы:
select 
c.client_id,
c.name as client_name 
from clients c 
left join orders o on o.client_id = c.client_id
where o.order_id is null 

Left join - LEFT JOIN (или LEFT OUTER JOIN) в SQL — это операция внешнего левого соединения, которая возвращает все записи
из левой (первой) таблицы и только те совпадающие записи из правой (второй) таблицы, которые соответствуют условию 
соединения (через оператор ON). Если для строки из левой таблицы нет соответствующей записи в правой, 
то для столбцов правой таблицы в результирующей строке будет подставлено значение NULL. 

Join ON - JOIN в SQL объединяет строки из двух или более таблиц на основе связанных столбцов,
используя оператор ON для определения условия объединения. Это позволяет получать более полную информацию, 
соединяя данные из разных таблиц, например, заказы с информацией о клиентах, когда у обеих таблиц есть общий идентификатор.

Как это работает:
1. Связь таблиц:
JOIN используется для объединения данных, которые физически находятся в разных таблицах,
но связаны общими данными (например, CustomerID). 
2. Условие ON:
Вы указываете, по каким именно столбцам таблицы должны быть сопоставлены с помощью предложения ON. 
3. Результат:
Оператор JOIN создает новую таблицу (результирующий набор), в которой строки из обеих таблиц объединены там, 
где условие в ON выполняется. 

Первый скрипт для триггера:
create or replace function update_order_item_price()
returns trigger as $$ 
begin 
	new.price :=(
	select price from products where product_id = new.product_id
	) * new.count;
return new;
end;
$$ language plpgsql;

Второй скрипт для триггера:
create trigger trg_calculate_order_item_price
before insert or update on order_items
for each row execute function 
update_order_item_price ();

Модуль 4. Клиент серверная разработка.
Интернет магазин.

Клиент:     Запросы <HTTP>(ответы)         Сервер: бизнес-логика+сервер        БД:Запрос <SQL>

Сервер - физ. или виртуальная высокопроизводительная машина (или пк), которая должна работать 24/7 и иметь доступ к интернету.
+ Сервер - это отдельное запущенное приложение (Node.JS).
Node.JS - это платформа для JS, построенная на движке W8, которая позволяет запускать JS код вне браузера, на сервере и на любом пк.

Ключевые принципы при работе с Node.JS.
1. Асинхроность и событийно-ориентированная архитектура.
1.1. Не блокирующий ввод/вывод, когда серверу нужно выполнить операцию ввода-вывода. (например: прочитать файл с диска, сделать запрос в бд, 
отправить сетевой запрос) оно не ждет ее завершения. Вместо этого оно продолжает выполнять другой код. Как только операция завершается 
вызывается специальная функция-оброботчик callback.
1.2. Однопоточность с циклом события. (event look).
(В основе JS лежит однопоточная модель. Однако это не значит, что он может делать только одну вещь за раз. Цикл событий - это механизм, который постоянно
проверяет завершились ли какие-либо асинхронные операции. Если операция завершина, он ставит ее callback в очередь на выполнение.) 
2. NPN (Nodepackage) - поставляется со своим менеджером пакетов NPN - это огромная экосистема открытых библиотек и инструментов, которую можно легко остановить и использовать в своем проекте.

Какие процессы и работы выполняются на сервере NodeJS (при клиентской разработке):
1 Этап: создание и настройка HTTP сервера. (Установка модуля Express.JS для быстрой настройки, создание экземпляра приложения и определение порта, на котором сервер будет принимать входящие и исходящие подключения.
2 Этап: подключение к бд. Для того, чтобы подключить JS к SQL используется важный модуль pg. Настройка подключения к субд с использованием соответствующего драйвера (pg) или ORM/ODM система. Создание конфигуруционного файла бд ( в нем мы указываем параметры подключения бд (host, loginhost и т.д.)).
3 Этап: разработка промежуточного оброботчика. Разрабатываются компоненты, которые обрабатывают входящие HTTP запросы до того, как они достигнут маршрута (midlewhere).
4 Этап: определение моделей данных. Разработка модуля, которая описывает структуры данных, которые будут храниться в бд. (таблицы, коллекции, поля, типы данных, связи). Это делается либо с помощью SQL скриптов на сервере или через ORM/ODM модулей.
5 Этап: создание маршрутов (routes и API-points). Разработка обработчика для различных HTTP запросов (GET, POST, PUT, DELETE) по определенным URL адресам (api-points). Каждый маршрут соответствует конкретной операции. 
6 Этап: реализация контроллеров (controles). Написание функций - обработчиков, которые привязаны к маршрутам. Эти функции содержат бизнес-логику: получают данные из запроса, взаимадействуют с бд (через модели) и отправляют ответ клиенту.
Nodemon - автоматически перезагружает сервер.
Sequelize - очень важен. ORM система, которая позволяет создавать модели данных, которые на языке JS позволяют описать сущности бд и атрибуты в них.

Хорошим тоном является разработка дополнительных модулей, отвечающих за обработку ошибок и валедация данных, настройка переменных окружения.
HTTP методы:
1. HTTP методы определяют действия, которые клиент хочет выполнить с ресурсами на сервере, они являются основной симантикой Restful API.
1. GET. Это безопасный метод для получения данных. Get /API /client
2. Post (создать/отправить). Небезопасный (меняет состояние сервера), неидемпотентный (два одинаковых запроса, создают два ресурсаю Данные запроса передаются в теле запроса (body)).
3. Put (обновить/заменить). Полное обновление или замена существующего ресурса. Если ресурса нет, то он может быть создан, но это не стадартно. Небезопасный и идемпотентный запорос. Пример: Put /API /clients /1 
4. Patch (частично обновить). Применяется для того, чтобы изменить email(пример) у пользователя. Небезопасный и идемпотентный.
5. Delete. Небезопасный и идемпотентный. 

Коды ответов сервера:
от 100 - 500 (это трехзначные символы, который отправляет http). Они сообщают клиенту результат операции и групперуются по первой цифре. 
1. соты(1хх) - это сервер готов принять схему запроса.
2. двухсотые (2хх) - запрос был успешно обработан. 201 - put. 204 - delete.
3. трехсотые (3хх) - перенаправление. Используется, чтобы сообщить клиенту, что для завершения запроса необходимо сделать дополнительные действия (Пример: перейти по-другому адресу). 301 - перемещен по новому адресу.
4. четырехсотые (4хх) - ошибка на клиенте. 400 - сервер не может обработать запрос из-за некоректного синтаксиса. 401 - не для авторизованных пользователей (требуется аутенфикация). 403 - сервер принял запрос, но отказывается авторизовать. 404 - сервер не может найти запрашиваемый ресурс. 429 - отправили слишком много запросов за маленькое время.
5. пятисотые (5хх) - ошибки сервера. Сервер не смог выполнить по своей вине. 

Таблица создается тегом <table>, шапка - <thead>, тело - <tbody>, подвал - <tfoot>.
В thead пишутся заголовки колонок. В tbody пишутся все значения колонок. В tfoot пишутся результаты подсчетов.
Строка создается с помощью тега - <tr>. <th>(заголовочная ячейка)/<td> - создаются ячейки. 

<table>
    <thead>
        <tr>
            <th>Директор </th>
            <th>Возраст</th>
            <th>Рейтинг</th>
            <th>Почта</th>
            <td>Телефон</td>
        </tr>
    </thead>
    <tbody>

    </tbody>
    <tfoot>

    </tfoot>
</table>

Задача: Необходимо написать функцию для отрисовки таблицы (добавление строк и ячеек) и записать в каждую ячейку соответсвующие данные из массива объекта (dataSet).
const thead = document.getElementById(".myTable_thead")
const tr = thead.insertRow(); - применяется к таблицам и позволяет создавать строку внутри родительского элемента
const td = tr.insertCell(); - добавляет ячейку.

const dataSet = [
    {id: 1, name: "Иванов А.А.", age: 20},
    {id: 2, name: "Смирнова Л.В.", age: 58},
    {id: 3, name: "Петров С.П.", age: 54}
];

const fillTbody = (dataSet) => {
    const tbody = document.getElementById("test");
    dataSet.forEach(element => {
        const tr = tbody.insertRow();
        tr.innerHTML = `
        <td>${element.id}</td>
        <td>${element.name}</td>
        <td>${element.age}</td>
        `;
    });
}
fillTbody(dataSet);

Минусы данного кода:
1. Данный код будет работать, он является хорошим примером, но только в случае, если структура массива с данными не будет меняться (не будут появляться новые атрибуты).
2. Потенциальная уязвимость при использовании внешних данных, если вдруг в данных окажется строка с HTML тегами, то при вставке через innerHTML этот код выполниться - это называется XSS уязвимость. Не рекомендуется отрисовывать данные через этот метод.

Вариант 2:
Более безопасный и контролируемый способ (создание элементов через createElement, appendChild и запись данных через TextContent. Это вариант решает проблему с XSS и дает больше контроля над данным элементом. Основная суть подхода зашить каждую ячейку в отдельную переменную и присвоить ей значение из массива через textContent (он безопасный), но есть один нюанс, мы будем ограничены в атрибутах. 

async function func () {
    try {
        const result = await alert ('5');
    }
    catch (error) {
    }
}

Async - функция может выполниться в любой момент.
Функция async делает две важные вещи: 1. Возвращает результат в виде promise. 2. Позволяет использовать await внутри функции.
Await заставляет JS ждать, пока promise не будет выполнен или отклонен. 

Создание модуля:
Чтобы получить файл json. Надо написать в терминале: npm init -y 
Чтобы установить модули в терминале пишем: npm install cors dotenv express pg pg-hstore sequelize. Перечисляем модули без запятых, через пробел.
Модуль nodemon стоит добавить отдельно от остальных (npm install -D nodemon).
В файле находиться слово test и несколько цифр. Стоит заменить на "dev": "nodemon index.js".

// reguire('dotenv').config() - метод commonJS
import 'dotenv/config' //ES modules
Есть два основных способа импорта и экспорта модулей. ESM более современный формат. Он соответствует последним стандартам ECMAscript.
//commonJS
// const express = require('express');
// const {Router} = require('express');
// module.exports = myFune;
// module.exports = {class1, class2};
// exports.myFune = () => {}


//ESM
// import express from 'express'
// import {Router} from 'express'
// import * as models from './node_modules'

//ESM
//export default myClass 
//export {class1, class2} 
//export const myFunc = () => {}

документация Dotenv - https://www.dotenv.org/docs/quickstart
документация express - https://expressjs.com/
sequelize документация - https://my-js.org/docs/guide/sequelize

Файл index.js основной файл для запуска сервера. В нем импортируются модули express, dotenv (пока что).
Файл db.js файл конфигурации баз данных. При этом подключение к бд происходит через объкт модуля sequelize.
Создаем папку модуля на сервере. Модель.js. Будем описывать модели данных. 

