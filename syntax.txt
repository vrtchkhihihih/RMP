Модуль 3 
РАЗРАБОТКА СЕРВЕРНОЙ ЧАСТИ

3.1 РАБОТА С БАЗОЙ ДАННЫХ.
БД - набор структурированной информации для какой-либо предметой области.
Реляционные БД - данные, представленные в виде таблицы.(excel)
Основные БД выражены в популярных предложениях: postgreSQL,mySQL, MsSQL server. 
Для работы с сервером PSQL, зачастую используется отдельное клиентское приложение.
Каждое значение первой строки является атрибутом. Значения атрибутов читаются построчно.
Для того, чтого, чтобы БД корректно работала, её необходимо нормализовать.
1. н.ф. все атрибуты и их значения атомарны(неделимы).
2. н.ф. в каждой таблице есть колонка с индивидуальными индефикаторами.
3. н.ф. когда для двух таблиц создаётся смежная таблица, которая связывает первые две.
Внешний ключ - ссылка из смежной таблицы на первичный ключ таблицы, с которой она связана.
В терминологии таблицы называются сущностями.
Первая строка в каждой таблице является критериями сущности.
Первичный ключ должен обладать следующими критериями: целое цисло, не отрицательное и не ноль, автозаполнение.
SQL запросы делят на следующие типы:
1. DDL-запрос - оператор определения данных.(СREATE, DROP)
2. DML-запрос - содержит операторы манипуляции данных, которые работают с содержимым таблицы.(UPDATE, SELECT, DELETE, INSERT)
3. DCL-запрос - операторы определения доступа к данным для разных пользователей.(GRANT, DENY)
4. TCL-запрос - язык управления транзакциями, то есть сериями комманд, которые выполняются поочерёдно.
Если хотябы одна из комманд не выполнена, все последующие тоже отменяются.(BEGIN TRANSACTION, COMMIT TRANSACTION, SAVE TRANSACTION)

ТИПЫ ДАННЫХ:
1. Наиболее подходящий тип данных для первичных ключей - это (small-, big-)serial.
2. Если количество символов примерно известно заранееи оно составялет не более 255, то правильне использовать varchar. Если нужно ограничить количество символом до 11, то пишут varchar(11).
3. Когда не известно коичество сиволов, ставится динамическая величина text.
4. Если данные имеют дробную часть, то используют тип данных - numeric
5. Для целочисленных значений без автозаполнения используется тип данных - integer.
Внешний ключ так же должен описываться через Integer.
6. Для записи даты чего-либо используют timastamp.

Запрос на вывод колчиства клиентов: 
select count(*) as total_clients from clients c 
Запрос на вывод среднего значения: 
select avg(price) as avg_price from products p 
Зарос на вывод минимального или максимального значения:
select min/max(price) as min_price from products p
Зарос на вывод количества открытых и закрытых запросов:
select count(*) as orders_count from orders o 
group by status
вывод части данных через смежную таблицу:
select order_id, fio, name,status, date from orders
join clients on clients.client_id = orders.client_id
join products on products.product_id  = orders.product_id 

left join Это операция внешнего левого соединения, которая возвращает все записи из левой(превой) таблицы и только те, совпадающие из правой(второй) таблицы, которые соответсвуют условию соединения(через оператор on)
 

4 МОДУЛЬ. КЛИЕНТ СЕРВЕРНАЯ РАЗРАБОТКА МАГАЗИНА.

сервер:
бизнес логика + сервер


сервер -  физическое или виртуальное высокопроизводительное устройство, которое должно иметь доступ к интернету. Также сервер это отдельно запущенное приложение(nodeJS)
NodeJS - Это платформа для JS, построенная на движке V8, которая позволяет запускать JS код вне браузера, на сервере и на любом компьютере.
Ключевые особенности при работе с NodeJS:
1. Асинхронность и событийно-ориентированная архитектура.
1.1 неблокирующий ввод\вывод. Когда серверу нужно выполнить операцию ввода\вывода(прочитать файл с диска, сделать запрос к бд, отправить сетевой запрос) оно не ждёт её завершения. Вместо этого, оно продолжает выполнять другой код. Как только операция завершается, вызывается специальная функция обработчик callback.
1.2 Однопоточность с циклом событий(eventloop). В основе JS лежит однопоточная модель. Однако это не значит, что он может делать одну вещь за раз. Цикл событий - это механизм, который постоянно проверяет, завершились ли какие-либо асинхронные операции. Если операция завершена, он ставит её callback в очередь на выполнение.
2. NPM(node package manager) - nodeJS поставляется со своим менеджером пакетов, это большая экосистема открытых библиотек и инструментов, которые можно установить и использовать в своём проекте.
Какие этапы работ выполняются на сервере nodeJS при разработке клиент серверных приложений
1. Создание http сервера. Подключаем expressJS. Создание экземпляра приложения и определение порта, на котром сервер будет принимать входящие и исходящие подключения.
2. Подключение к базе данных. подключаем pg. Настройка подключения к СУБД с использованием соответствующего драйвера(pg или ORM/ODM системы). Создение конфигурационного файла БД(указать параметры подключения к базе данных)
3.Разработка промежуточных обработчиков(middle-wear). Разрабатываются компоненты, которые обрабатывают входящие http запросы, до того, как они достигнут маршрута
4. Определение можелей данных. Разработка модуля, который описывает структуры данных, которые будут храниться в базе данных.(таблицы, коллекции, типы данных, связи). Это делается с помощью sql-скриптов, либо через ORM/ODM модули.
5. Создание маршрутов(routes И API-endpoints). РАзработка обработчиков для различных http запросов(GET,POST,PUT, DELETE) по определённым url адресам(endpoiut-ам). Каждый маршут соответствует конкретной операции
6. Реализация контроллеров. Написание функций - обработчико, которые привязаны к маршрутам. Эти функции содержат бизнес-логику(получают данные из запроса, взаимодействуют через модели и отправляют ответ клиенту.

Хорошим тоном является разработка дополнительных модулей, отвечающих за обработку ошибок и валидации данных, настройка переменных окружения
 HTTP-методы
Эти методы определяют действия, которые клиент хочет выполнить с серусрами на сервере. Они являются основной симантикой (логикой) restfulAPI
1. метод GET. Это безопасный метод для получения данных в бд. 
get /api/clients/1 - Данный запрос возвращает данные клиента с id=1.
2. метод POST - небезопасный(меняет состояние сервера), не иденпотентный(2 одинаковых запроса создадут два ресурса). Данные запроса передаются в теле(body).
3. метод PUT - обновить/заменить. Полное обновление или замена существующего ресурса. Небезопасный иденпотентный запрос.
4. метод PATCH - частично обновить. Применяется для изменения данных у пользователя. Небезопасный иденпотентный запрос.
5. метод DELETE - удаление указанного ресурса. Небезопасный иденпотентный запрос.

Коды ответов сервера.
Это трёхзначные числа, которые лежат от 100 до 503, которые сервер отправляет на http запрос. Они сообщают клиенту результат выполнения операции и группируются по первой цифре.
1. 1хх - информационные. 100 - сервер готов принять тело запроса.
2. 2хх - сообщение об успехе - сообщение о том, что запрос успешно обработан
3. 3хх - перенапаовление - сообщают клиенту, что для выполнения запроса необходимо выполнить дополниельное действие(перейти по другому адресу)
4. 4хх - ошибки клиента. 400 - сервер не может обработать запрос, из-за некорректного синтаксиса. 429 - клиент отправил слишком много запросов за короткое время.
5. 5хх - ошибки сервера - указывает что сервер не смог выполнить запрос по своей вине. появляется из-за бага в коде.


РАБОТА С ДАННЫМИ В ТАБЛИЦЕ
создание таблицы:
<table>
    <thead>
            <tr> 
               <th>директор</th>
               <th>возраст</th>
               <th>рейтинг</th>
               <th>почта</th>
               <td>телефон</td>
            </tr>
    </thead>
    <tbody>

    </tbody>
    <tfoot>

    </tfoot>
</table>
Таблица состоит из 3-ёх основных частей: thead - заголовки колонок, tbody - пишется основная часть данных, tfoot -  выполняются  отдельные подсчёты
<tr> - создание одной строки
<th> - заголовочные ячейки
<tr> - ячейки
Необходимо написать функцию, для отрисовки таблицы(добавление строк и ячеек) и вписать соответствующие данные из массива объектов dataset
const  thead = document.getElementById("myTable_thead");
const tr = thead.insertRow();
const td = tr.insertCell
Функция insertRow позволяет создавать строку внутри родительского элемент, а insertCell создаёт ячейку внутри родительского элемента

Пример с использованием innerHTML является хорошим, но если структура данных не будет менятся(не будут появляться новые атрибуты) имеет большой минус, так как, с помощью данного метода можно перехватить данные.
Если вдруг в данных окажется строка с HTML тегами, то при вставке через innerHTML этот код выполниться. Это называется XSS-уязвимость. Не рекомендуется отрисовывать данные через innerHTML.
Пример 2. Более бесопастный и контролируемый способ( создание элементов через createElement, appendChild и запись данных через textContent). Этот вариант решает проблему XSS и даёт больше контроля над каждым элементом.

const createTable = (dataSet) => {
    const  tbody = document.getElementById("myTbody");

    dataSet.forEach(element => {
    const row = document.createElement('tr');
    const cellId = document.createElement('td');
    row.appendChild(cellId);
    const cellName = document.createElement('td');
    row.appendChild(cellName);
    const cellAge = document.createElement('td');
    row.appendChild(cellAge);        
        cellId.textContent = element.id;
        cellName.textContent = element.name;
        cellAge.textContent = element.age;
    tbody.appendChild(row);        
    });

}

createTable(dataSet);

ЗАДАНИЕ:
Добавить вторую функцию, которая при нажатии на кнопку(html) будет брать стоковое значение из input-поля и применять фильтр к данным для заполнения таблицы
input.value
filter
includes
String
добавить кнопку удаления фильтра

// require('dotenv').config(); commonJS
import 'dotenv/config' // ES modules
есть 2 основных способа импорта и экспорта модулей.
ESM Более современный формат. Он соответствует ECMAScript

require('dotenv').config(); //commonJS
import 'dotenv/config' // ES modules
commonJS

const express = require('express');
const {router} = require('express');

module.exports = myfunc;

exports.myfunc = () => {

};


ESM
import express from 'express';
import {router} from 'express';

import * as models from './models';


export default myClass;
export {class1, class2};

export const myFunc = () => {

};
файл index.js - это основной файл для запуска сервера. В нём импортируются модули express и .env.
Файл db.js - Файл конфигурации БД. При этом подключение к бд происходит с помощью объекта модуля Sequelize

В папке models создаём исполняемый файл models.js в котором будем описывать модели данных(сущности)

SERIAL -> INTEGER
	+ autoIncrement
	+ primaryKey

VARCHAR(n) -> DataTypes.STRING

Numeric(p,s) -> DataTypes.DECIMAL(p,s)

Пример описания модели данных на базе таблицы clients:
const Client = sequelize.define(
    'Clients',
    {
        id:{
            type: DataTypes.INTEGER,
            allowNull: false,
            primaryKey: true,
            autoIncrement: true,
        },
        name:{
            type: DataTypes.STRING(50),
            allowNull: false,
        },
        rating:{
            type: DataTypes.DECIMAL,
            allowNull:false,
            defaultValue: 0,
        },
        age:{
            type: DataTypes.DATE,
            allowNull: false,
        },
        role:{
            type: DataTypes.STRING,
            allowNull: false,
            defaultValue: 'user',
        }
    }
)


После описания модели данных Client, Product, Order, Order_item.
После этого мы должны экспортиртировать(export default {Client, Product, Order, Order_item};) и импортировать их в index.js.
Помимо это необходимо добавить promise в блоке try функции start для создания/перезаписи таблиц в бд. Это делается через функцию sequelize.sync().

Для создания связей используются следющие конструкции:

Client.hasMany(Order)
Order.belongsTo(Client)


3 ЭТАП. Разработка маршрутов и APIEndPoint.	

Пример get запроса:
app.use(cors());
app.use(express.json());
// get запрос
app.get('/',(req, res) => {
    res.status(200).json({message: 'work!'});
});

use - это метод настройки промежуточного ПО используемого маршрутами объекта сервера express.
express.json() - это встроенная функция, разбирающая входные запросы в объект формата json.
get - принимает в себя 2 аргумента и функцию:
1. http метод(get, post, put, delete, patch и т.д.)
2. пусть на сервере
3. дополнительная heandler function выполняется при совпадении маршрута

request(req) - объект запроса т.е. то, что прислал клиент, из него читаем данные.
response(res) - объект ответа, в него записываем данные в ответ клиенту(статус, json Объект)

get запрос работает, но его необходимо оформить более правильным способом:
1. сделать метод асинхронным.
2. обезопасить код.
3. добавить обработку ошибок.
4. сделать маршрут более конкретным.


const {Client} = models;

app.get('/api/getclients', async(req,res) =>{
    try{
        const getClietns = await Client.findAll() 


        res.status(200).json(getClietns)
    }
    catch(error){
        res.status(500).json({message: 'ошибка сервера при получении даннных'})
    };
});
теперь он передаёт бд, дальше добавим маршрутизацию.

Э
http методы нужно разнести по разным моделям данных, которые необходимо разнести по разным модулям.
Создаём папку routes и в ней создаём router для каждой модели данных(clientRouter,js).
Добавляем файл router.js, который будет главным маршрутизатором. Он будет вызывать нужные функции со своими маршрутами при получении запроса с браузера.






